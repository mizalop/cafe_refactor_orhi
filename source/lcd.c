/* ###################################################################
 **     This component module is generated by Processor Expert. Do not modify it.
 **     Filename    : lcd.c
 **     Project     : dsf
 **     Processor   : MKL25Z128VLK4
 **     Component   : LCDHTA
 **     Version     : Component 01.022, Driver 01.00, CPU db: 3.00.000
 **     Repository  : Legacy User Components
 **     Compiler    : GNU C Compiler
 **     Date/Time   : 2017-01-16, 17:35, # CodeGen: 2
 **     Abstract    :
 **          This component implements a driver for multiple 2x16 character displays.
 **     Settings    :
 **          Component name                                 : lcd
 **          HW Interface                                   :
 **            LCD Type                                     : generic
 **            LCD Lines                                    : 2
 **            Characters per Line                          : 8
 **            Line Addresses                               :
 **              Line 1                                     : 0x00
 **              Line 2                                     : 0x40
 **              Line 3                                     : 0x10
 **              Line 4                                     : 0x50
 **            LCD Enable Signal                            : Disabled
 **            Read from Display                            : Disabled
 **            Wait (us)                                    : 0
 **            E signal                                     : CtrlPin
 **            E2                                           : Disabled
 **            RS signal                                    : CtrlPin
 **            Data/Control Bus                             :
 **              Data/Control Bus Width                     : 8bit
 **              DB0..DB3                                   : Enabled
 **                DB0                                      : DBpin
 **                DB1                                      : DBpin
 **                DB2                                      : DBpin
 **                DB3                                      : DBpin
 **              DB4..DB7                                   : Enabled
 **                DB4                                      : DBpin
 **                DB5                                      : DBpin
 **                DB6                                      : DBpin
 **                DB7                                      : DBpin
 **              Bits/Byte Bus                              : Disabled
 **          System Interface                               :
 **            Wait                                         : WAIT1
 **     Contents    :
 **         WriteLCDCommand  - void lcd_WriteLCDCommand(uint8_t cmd);
 **         Write            - void lcd_Write(uint8_t ch);
 **         WriteLn          - void lcd_WriteLn(void);
 **         WriteLineStr     - void lcd_WriteLineStr(uint8_t line, uint8_t *str);
 **         WriteString      - void lcd_WriteString(uint8_t *str);
 **         LoadSoftChar     - void lcd_LoadSoftChar(uint8_t charCode, uint8_t *softChar);
 **         ShiftLeft        - void lcd_ShiftLeft(void);
 **         ShiftRight       - void lcd_ShiftRight(void);
 **         GotoXY           - void lcd_GotoXY(uint8_t line, uint8_t column);
 **         SetEntryMode     - void lcd_SetEntryMode(bool increment, bool shiftLeft);
 **         CursorOn         - void lcd_CursorOn(void);
 **         CursorOff        - void lcd_CursorOff(void);
 **         CursorShiftRight - void lcd_CursorShiftRight(void);
 **         CursorShiftLeft  - void lcd_CursorShiftLeft(void);
 **         BlinkingOn       - void lcd_BlinkingOn(void);
 **         BlinkingOff      - void lcd_BlinkingOff(void);
 **         Home             - void lcd_Home(void);
 **         Line             - void lcd_Line(uint8_t line);
 **         Clear            - void lcd_Clear(void);
 **         UseDisplay       - uint8_t lcd_UseDisplay(uint8_t display);
 **
 **     License   :  Open Source (LGPL)
 **     Copyright : (c) Copyright Erich Styger, 2008-2014, all rights reserved.
 **     http      : www.mcuoneclipse.com
 **     This an open source software implementing software using Processor Expert.
 **     This is a free software and is opened for education,  research  and commercial developments under license policy of following terms:
 **     * This is a free software and there is NO WARRANTY.
 **     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
 **     * Redistributions of source code must retain the above copyright notice.
 ** ###################################################################*/
/*!
 ** @file lcd.c
 ** @version 01.00
 ** @brief
 **          This component implements a driver for multiple 2x16 character displays.
 */
/*!
 **  @addtogroup lcd_module lcd module documentation
 **  @{
 */

/* MODULE lcd. */


#include "fsl_gpio.h"
#include "pin_mux.h"
#include "lcd.h"


/* DEFINES for display commands.
   See
   - www.freescale.com/files/microcontrollers/doc/app_note/AN1745.pdf
   - http://www.mikrocontroller.net/articles/HD44780
   for additional details.
 */
#define ClearDisplayCmd                 0x01 /* clears the display */

#define ReturnHomeCmd                   0x02 /* moves the cursor to the beginning of the first line */

#define EntryModeSetCmd                 0x04
#define EntryModeSet_ShiftOn             1 /* S flag: shift display */
#define EntryModeSet_IncrementOn         2 /* I/D flag: increment cursor */

#define DisplayOnOffControlCmd          0x08 /* Display on/off control command. There are 3 bits D, C and B as well */
#define DisplayOnOffControl_BlinkOn      1 /* B flag: blinking cursor on/off; B=1 blinking, B=0 not blinking */
#define DisplayOnOffControl_CursorOn     2 /* C flag: cursor on/off, C=1 cursor on, C=0 cursor off */
#define DisplayOnOffControl_DisplayOn    4 /* D flag: display on/off, D=1 display on, D=0 display off */

#define FunctionSetCmd                  0x20
#define FunctionSet_8bit              0x10 /* DL flag: DL=1: 8bit, DL=0: 4bit */
#define FunctionSet_4bit                 0 /* DL flag: DL=1: 8bit, DL=0: 4bit */
#define FunctionSet_2Lines            0x08 /* N flag: number of display lines: N=1 2 or 4 lines, N=0 1 line */
#define FunctionSet_1Line                0 /* N flag: number of display lines: N=1 2 or 4 lines, N=0 1 line */
#define FunctionSet_Font5x10          0x04 /* F flag: character font, F=1 5x10 dots, F=0 5x8 dots */
#define FunctionSet_Font5x8              0 /* F flag: character font, F=1 5x10 dots, F=0 5x8 dots */

#define CursorOnCmd         (DisplayOnOffControlCmd|DisplayOnOffControl_DisplayOn|DisplayOnOffControl_CursorOn)
#define CursorOffCmd        (DisplayOnOffControlCmd|DisplayOnOffControl_DisplayOn)
#define GotoXYCmd           0x80  /* 0x80 | Display RAM address */
#define Line1Offset         0x00 /* Display RAM address of first line, usually 0x00 */
#define Line2Offset         0x40 /* Display RAM address of second line, usually 0x40 */
#define Line3Offset         0x10 /* Display RAM address of third line, usually 0x10 */
#define Line4Offset         0x50 /* Display RAM address of fourth line, usually 0x50 */
#define FirstLineCmd        (GotoXYCmd|Line1Offset)
#define SecondLineCmd       (GotoXYCmd|Line2Offset)
#define ThirdLineCmd        (GotoXYCmd|Line3Offset)
#define FourthLineCmd       (GotoXYCmd|Line4Offset)

#define RightShiftCmd       0x1C
#define LeftShiftCmd        0x18
#define RightShiftCursor    0x14
#define LeftShiftCursor     0x10


static uint8_t DisplayOnOffControlStatus;

#define BusyFlag       0x80 /* BF Flag */

/* support for custom soft characters in the display which can be used with lcd_LoadSoftChar() */
const uint8_t lcd_SoftCharMAG[8] = { /* MAG */
		0x00, 0x00, 0x1C, 0x02, 0x19, 0x05, 0x15, 0
		/* .....
   .....
   XXX..
   ...X.
   XX..X
   ..X.X
   X.X.X */
};

const uint8_t lcd_SoftCharARROW[8] = { /* ARROW */
		0x04, 0x04, 0x04, 0x04, 0x15, 0x0E, 0x04, 0
		/* ..X..
   ..X..
   ..X..
   ..X..
   X.X.X
   .XXX.
   ..X.. */
};

//lcd_SOFTCHAR_LEFT_UP_BOX
const uint8_t lcd_SoftCharLEFTBOXUP[64] = {  /*Lateral izquierdo caja 8 escalones*/
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,	// 0  Caja vacia SIN suelo
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F,	// 1  Caja 15% llena
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x1F,	// 2  Caja 30% llena
	0x10, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x1F,	// 3  Caja 45% llena
	0x10, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x1F, 0x1F,	// 4  Caja 60% llena
	0x10, 0x10, 0x10, 0x17, 0x1F, 0x1F, 0x1F, 0x1F,	// 5  Caja 75% llena
	0x10, 0x10, 0x13, 0x17, 0x1F, 0x1F, 0x1F, 0x1F,	// 6  Caja 90% llena
	0x10, 0x11, 0x13, 0x17, 0x1F, 0x1F, 0x1F, 0x1F 	// 7  Caja llena hasta arriba
/* 	X....
   	X...X
   	X..XX
   	X.XXX
    XXXXX
    XXXXX
    XXXXX
    XXXXX */
};

//lcd_SOFTCHAR_CENTER_UP_BOX
const uint8_t lcd_SoftCharCENTERBOXUP[64] = {		/* Centro caja 8 escalones */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// 0  Caja vacia solo suelo
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F,	// 1  Caja 15% llena
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F,	// 2  Caja 30% llena
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F,	// 3  Caja 45% llena
	0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x1F,	// 4  Caja 60% llena
	0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 5  Caja 75% llena
	0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 6  Caja 90% llena
	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F  // 7  Caja llena hasta arriba
/* 	XXXXX
	XXXXX
	XXXXX
	XXXXX
	XXXXX
	XXXXX
	XXXXX
	XXXXX */
};

//lcd_SOFTCHAR_RIGHT_UP_BOX
const uint8_t lcd_SoftCharRIGHTBOXUP[64] = {		  /* Lateral derecho 8 escalones */
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,	// 0  Caja vacia solo suelo
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1F,	// 1  Caja 15% llena
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1F, 0x1F,	// 2  Caja 30% llena
	0x01, 0x01, 0x01, 0x01, 0x01, 0x1F, 0x1F, 0x1F,	// 3  Caja 45% llena
	0x01, 0x01, 0x01, 0x01, 0x1F, 0x1F, 0x1F, 0x1F,	// 4  Caja 60% llena
	0x01, 0x01, 0x01, 0x1D, 0x1F, 0x1F, 0x1F, 0x1F,	// 5  Caja 75% llena
	0x01, 0x01, 0x19, 0x1D, 0x1F, 0x1F, 0x1F, 0x1F,	// 6  Caja 90% llena
	0x01, 0x11, 0x19, 0x1D, 0x1F, 0x1F, 0x1F, 0x1F 	// 7  Caja llena hasta arriba
/* ....X
   X...X
   XX..X
   XXX.X
   XXXXX
   XXXXX
   XXXXX
   XXXXX */
};

//lcd_SOFTCHAR_LEFT_DOWN_BOX
const uint8_t lcd_SoftCharLEFTBOXDOWN[64] = {  /* Lateral izquierdo caja 8 escalones */
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F,	// 0  Caja vacia solo suelo
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x1F,	// 1  Caja 15% llena
	0x10, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x1F,	// 2  Caja 30% llena
	0x10, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x1F, 0x1F,	// 3  Caja 45% llena
	0x10, 0x10, 0x10, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 4  Caja 60% llena
	0x10, 0x10, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 5  Caja 75% llena
	0x10, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 6  Caja 90% llena
	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F 	// 7  Caja llena hasta arriba
/* 	XXXXX
   	XXXXX
   	XXXXX
   	XXXXX
    XXXXX
    XXXXX
    XXXXX
    XXXXX */
};

//lcd_SOFTCHAR_CENTER_DOWN_BOX
const uint8_t lcd_SoftCharCENTERBOXDOWN[64] = {		/*  Centro caja 8 escalones */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F,	// 0  Caja vacia solo suelo
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F,	// 1  Caja 15% llena
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F,	// 2  Caja 30% llena
	0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x1F,	// 3  Caja 45% llena
	0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 4  Caja 60% llena
	0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 5  Caja 75% llena
	0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 6  Caja 90% llena
	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F 	// 7  Caja llena hasta arriba*/
/* 	XXXXX
	XXXXX
	XXXXX
	XXXXX
	XXXXX
	XXXXX
	XXXXX
	XXXXX */
};

//lcd_SOFTCHAR_RIGHT_DOWN_BOX
const uint8_t lcd_SoftCharRIGHTBOXDOWN[64] = {		 /* Lateral derecho 8 escalones */
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1F,	// 0  Caja vacia solo suelo
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1F, 0x1F,	// 1  Caja 15% llena
	0x01, 0x01, 0x01, 0x01, 0x01, 0x1F, 0x1F, 0x1F,	// 2  Caja 30% llena
	0x01, 0x01, 0x01, 0x01, 0x1F, 0x1F, 0x1F, 0x1F,	// 3  Caja 45% llena
	0x01, 0x01, 0x01, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 4  Caja 60% llena
	0x01, 0x01, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 5  Caja 75% llena
	0x01, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,	// 6  Caja 90% llena
	0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F 	// 7  Caja llena hasta arriba*/
/* XXXXX
   XXXXX
   XXXXX
   XXXXX
   XXXXX
   XXXXX
   XXXXX
   XXXXX */
};

const uint8_t lcd_SoftCharMICRODOSE[8] = { 		 /* Montonico en la caja vacia	 */
	0x00, 0x00, 0x00, 0x00, 0x04, 0x0E, 0x1F, 0x1F
/* .....
   .....
   .....
   .....
   ..X..
   .XXX.
   XXXXX
   XXXXX */
};

/* waiting macros */
#define Waitns(x) \
		wait_Waitns(x)                 /* Wait x ns */
#define Waitus(x) \
		wait_Waitus(x)                 /* Wait x us */
#define Waitms(x) \
		wait_Waitms(x)                 /* Wait x ms */

/* timings from Hitachi HD44708.pdf */
#define Timing_PWeh_ns   250 /* PWeh: Enable Pulse width (high level) */
#define Timing_tAS_ns     40 /* tAB: Address set-up time (RS, RW to E ) */
#define Timing_tDDR_ns   180 /* tDDR: Data delay time */
#define Timing_tCYCLE_ns 500 /* tCYLE: Enable Cycle time */

#define lcd_WAIT_DISPLAY_US                       0 /* wait time as specified in properties */
#define lcd_WAIT_LCD_CMD_AFTER_4BIT_DATA1_US     15 /* wait time after first 4bit data */
#define lcd_WAIT_LCD_CMD_AFTER_4BIT_DATA2_US     60 /* wait time after second 4bit data */

#define lcd_WAIT_LCD_READY                        1 /* Read busy flag */


#define ERR_OK                                    0x00U /*!< OK */

// Pin configuration as GPIO Output and default value 0
static const gpio_pin_config_t GPIO_configOutput = { kGPIO_DigitalOutput, 0 };

// Pin configuration as GPIO Input
static const gpio_pin_config_t GPIO_configInput   = { kGPIO_DigitalInput, 0 };


/* functions for the RW pin */
static void ClrRW(void)
{
	GPIO_PinWrite(LCD_RW_GPIO, LCD_RW_PIN, 0);    /* RS=0: command mode */
}

static void SetRW(void)
{
	GPIO_PinWrite(LCD_RW_GPIO, LCD_RW_PIN, 1);    /* RS=1: data mode */
}

static void RWAsOutput(void)
{
	/* mux LCD_RW as output */
	GPIO_PinInit(LCD_RW_GPIO, LCD_RW_PIN, &GPIO_configOutput);
}


/* functions for the RS pin */
static void ClrRS(void)
{
	GPIO_PinWrite(LCD_RS_GPIO, LCD_RS_PIN, 0);    /* RS=0: command mode */
}

static void SetRS(void)
{
	GPIO_PinWrite(LCD_RS_GPIO, LCD_RS_PIN, 1);    /* RS=1: data mode */
}

static void RSAsOutput(void)
{
	/* mux LCD_RS as output */
	GPIO_PinInit(LCD_RS_GPIO, LCD_RS_PIN, &GPIO_configOutput);
}


/* functions for the EN pin */
static void ClrEN(void)
{
	GPIO_PinWrite(LCD_CE_GPIO, LCD_CE_PIN, 0);    /* EN=0 */
}

static void SetEN(void)
{
	GPIO_PinWrite(LCD_CE_GPIO, LCD_CE_PIN, 1);    /* EN=1 */
}

static void ENAsOutput(void)
{
	/* mux LCD_CE as output */
	GPIO_PinInit(LCD_CE_GPIO, LCD_CE_PIN, &GPIO_configOutput);
}


/* functions for the data bus */
static void DataAsOutput(void)
{
	/* mux LCD_DB0~7 as output */
	GPIO_PinInit(LCD_DB0_GPIO, LCD_DB0_PIN, &GPIO_configOutput);
	GPIO_PinInit(LCD_DB1_GPIO, LCD_DB1_PIN, &GPIO_configOutput);
	GPIO_PinInit(LCD_DB2_GPIO, LCD_DB2_PIN, &GPIO_configOutput);
	GPIO_PinInit(LCD_DB3_GPIO, LCD_DB3_PIN, &GPIO_configOutput);
	GPIO_PinInit(LCD_DB4_GPIO, LCD_DB4_PIN, &GPIO_configOutput);
	GPIO_PinInit(LCD_DB5_GPIO, LCD_DB5_PIN, &GPIO_configOutput);
	GPIO_PinInit(LCD_DB6_GPIO, LCD_DB6_PIN, &GPIO_configOutput);
	GPIO_PinInit(LCD_DB7_GPIO, LCD_DB7_PIN, &GPIO_configOutput);
}

static void DataAsInput(void)
{
	/* mux LCD_DB0~7 as input */
	GPIO_PinInit(LCD_DB0_GPIO, LCD_DB0_PIN, &GPIO_configInput);
	GPIO_PinInit(LCD_DB1_GPIO, LCD_DB1_PIN, &GPIO_configInput);
	GPIO_PinInit(LCD_DB2_GPIO, LCD_DB2_PIN, &GPIO_configInput);
	GPIO_PinInit(LCD_DB3_GPIO, LCD_DB3_PIN, &GPIO_configInput);
	GPIO_PinInit(LCD_DB4_GPIO, LCD_DB4_PIN, &GPIO_configInput);
	GPIO_PinInit(LCD_DB5_GPIO, LCD_DB5_PIN, &GPIO_configInput);
	GPIO_PinInit(LCD_DB6_GPIO, LCD_DB6_PIN, &GPIO_configInput);
	GPIO_PinInit(LCD_DB7_GPIO, LCD_DB7_PIN, &GPIO_configInput);
}


static uint8_t DataGet(void) {
	uint8_t val;

	/* Get data from LCD_DB0~7 */
	val = (GPIO_PinRead(LCD_DB0_GPIO, LCD_DB0_PIN)<<0)
    		   |(GPIO_PinRead(LCD_DB1_GPIO, LCD_DB1_PIN)<<1)
			   |(GPIO_PinRead(LCD_DB2_GPIO, LCD_DB2_PIN)<<2)
			   |(GPIO_PinRead(LCD_DB3_GPIO, LCD_DB3_PIN)<<3)
			   |(GPIO_PinRead(LCD_DB4_GPIO, LCD_DB4_PIN)<<4)
			   |(GPIO_PinRead(LCD_DB5_GPIO, LCD_DB5_PIN)<<5)
			   |(GPIO_PinRead(LCD_DB6_GPIO, LCD_DB6_PIN)<<6)
			   |(GPIO_PinRead(LCD_DB7_GPIO, LCD_DB7_PIN)<<7);
	return val;
}

static void DataPut(uint8_t val) {
	/* Put data to LCD_DB0~7 */
	GPIO_PinWrite(LCD_DB0_GPIO, LCD_DB0_PIN, (val&(1<<0))!=0);
	GPIO_PinWrite(LCD_DB1_GPIO, LCD_DB1_PIN, (val&(1<<1))!=0);
	GPIO_PinWrite(LCD_DB2_GPIO, LCD_DB2_PIN, (val&(1<<2))!=0);
	GPIO_PinWrite(LCD_DB3_GPIO, LCD_DB3_PIN, (val&(1<<3))!=0);
	GPIO_PinWrite(LCD_DB4_GPIO, LCD_DB4_PIN, (val&(1<<4))!=0);
	GPIO_PinWrite(LCD_DB5_GPIO, LCD_DB5_PIN, (val&(1<<5))!=0);
	GPIO_PinWrite(LCD_DB6_GPIO, LCD_DB6_PIN, (val&(1<<6))!=0);
	GPIO_PinWrite(LCD_DB7_GPIO, LCD_DB7_PIN, (val&(1<<7))!=0);
}

/* Internal method prototypes */
static void EnablePulse(void);

/*
 ** ===================================================================
 **     Method      :  EnablePulse (component LCDHTA)
 **
 **     Description :
 **         Creates a pulse to transfer data and/or commands
 **         This method is internal. It is used by Processor Expert only.
 ** ===================================================================
 */
static void EnablePulse(void)
{
	SetEN();
	Waitns(Timing_PWeh_ns);
	ClrEN();                              /* set to 0 to finish pulse */
}

/*
 **     Description :
 **         Waits until the display is ready
 **         This method is internal. It is used by Processor Expert only.
 ** ===================================================================
 */
void lcd_WaitForLCDReady(void)
{
	uint8_t ch;

	/* Wait until the display is ready for new data.
     This means that we wait until the busy flag (MSB) in the status register is cleared */
	DataAsInput();                        /* set data port as input */
	SetRW();                              /* RW = 1: read mode */
	Waitns(Timing_tAS_ns);
	for(;;) {                             /* loop breaks as soon the busy flag is cleared */
		SetEN();                            /* EN = 1; EN to high for getting the busy flag  */
		Waitns(Timing_tDDR_ns);             /* Read mode timing tDDR: time until we can read data */
		ch = DataGet();                     /* read status */
		Waitns(Timing_PWeh_ns-Timing_tDDR_ns); /* for accurate length of EN pulse */
		ClrEN();
		if (!(ch&BusyFlag)) {
			break;
		}
		Waitns(Timing_tCYCLE_ns-Timing_PWeh_ns); /* need to wait a cycle time until we can enable EN again */
	} /* for */
	ClrRW();                              /* RW = 0: back to write mode */
	DataAsOutput();                       /* set data port as output */
}

/*
 ** ===================================================================
 **     Method      :  lcd_WriteLCDCommand (component LCDHTA)
 **     Description :
 **         Writes a command to the display
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         cmd             - command passed to the LCD
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_WriteLCDCommand(uint8_t cmd)
{
#if lcd_WAIT_DISPLAY_US > 0
	Waitus(lcd_WAIT_DISPLAY_US);          /* wait for some time not to write to the display while he may be busy with previous command */
#endif
#if lcd_WAIT_LCD_READY
	lcd_WaitForLCDReady();                /* Wait until LCD is ready */
#endif
	/* 8bit transfer */
	DataPut(cmd);                         /* put data on bus */
	EnablePulse();                        /* do the command transfer */
}

/*
 ** ===================================================================
 **     Method      :  lcd_Clear (component LCDHTA)
 **     Description :
 **         Clears the display and moves the cursor to the first line.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_Clear(void)
{
	lcd_WriteLCDCommand(ClearDisplayCmd); /* send the clear command to the LCD */
	//Para evitar el cursor parpadeante
	lcd_BlinkingOff();
}

/*
 ** ===================================================================
 **     Method      :  lcd_Home (component LCDHTA)
 **     Description :
 **         Moves the cursor to the beginning of the first line.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_Home(void)
{
	lcd_WriteLCDCommand(ReturnHomeCmd);   /* moves the cursor to the beginning of the first line */
}

/*
 ** ===================================================================
 **     Method      :  lcd_WriteLCDData (component LCDHTA)
 **
 **     Description :
 **         Writes data to the display
 **         This method is internal. It is used by Processor Expert only.
 ** ===================================================================
 */
void lcd_WriteLCDData(uint8_t ch)
{
#if lcd_WAIT_DISPLAY_US > 0
	Waitus(lcd_WAIT_DISPLAY_US);         /* wait for some time not to write to the display while he may be busy with previous command */
#endif
#if lcd_WAIT_LCD_READY
	lcd_WaitForLCDReady();               /* Wait until LCD is ready */
#endif
	SetRS();                             /* RS = 1: data mode */
	/* 8bit data transfer */
	DataPut(ch);                         /* put data on bus */
	EnablePulse();                       /* do the command transfer */
	ClrRS();                             /* RS = 0: back to command mode */
}

/*
 ** ===================================================================
 **     Method      :  lcd_GotoXY (component LCDHTA)
 **     Description :
 **         Places the cursor on a specified position on the display.
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         line            - Line number starting with 1
 **         column          - Column number starting with 1
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_GotoXY(uint8_t line, uint8_t column)
{
	/* row is in the range 1..LCD_Nof_Lines and column in the range 1..LCD_Nof_Columns */
	lcd_WriteLCDCommand((uint8_t)(GotoXYCmd + (column-1) + (line==1 ? 0x00:Line2Offset)));
}

/*
 ** ===================================================================
 **     Method      :  lcd_ShiftLeft (component LCDHTA)
 **     Description :
 **         Shifts all characters to the left.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_ShiftLeft(void)
{
	lcd_WriteLCDCommand(LeftShiftCmd);
}

/*
 ** ===================================================================
 **     Method      :  lcd_Write (component LCDHTA)
 **     Description :
 **         Write a single character to the display
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         ch              - Character to write
 **     Returns     : Nothing
 ** ===================================================================
 */
/* The method is implemented as a macro, see lcd.h */
/*
 ** ===================================================================
 **     Method      :  lcd_WriteLn (component LCDHTA)
 **     Description :
 **         Writes a new line to the display
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_WriteLn(void)
{
	lcd_WriteLCDCommand(SecondLineCmd);
}

/*
 ** ===================================================================
 **     Method      :  lcd_WriteString (component LCDHTA)
 **     Description :
 **         Writes a string to the display at the current cursor
 **         position.
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **       * str             - Pointer to string (zero byte terminated)
 **                           to write to the display
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_WriteString(char *str)
{
	while (*str != '\0'){
		lcd_Write(*str);
		str++;
	}
}

/*
 ** ===================================================================
 **     Method      :  lcd_WriteLineStr (component LCDHTA)
 **     Description :
 **         Writes a full line to the display (clears the rest of the
 **         line).
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         line            - Line number (starting with 1).
 **       * str             - Pointer to the string which should be
 **                           shown on the display.
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_WriteLineStr(uint8_t line, char *str)
{
	uint8_t i;

	lcd_Line(line);                       /* select line */
	for(i = 0; i < lcd_MAX_LCD_LINE_CHARS && *str!='\0'; i++, str++) {
		lcd_Write(*str);
	}
	/* Clear the rest of the line */
	for (; i < lcd_MAX_LCD_LINE_CHARS; i++) {
		lcd_Write(' ');
	}
}

/*
 ** ===================================================================
 **     Method      :  lcd_WriteFullStr (component LCDHTA)
 **     Description :
 **         Writes a full text to the display, starting from the 1st
 **         line. If text is longer than lcd_MAX_LCD_LINE_CHARS chars,
 **         jumps at the whitespace.
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **       * str             - Pointer to the string which should be
 **                           shown on the display.
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_WriteFullStr(char *str)
{
	uint8_t i;
	uint8_t length;

	length = strlen(str);

	lcd_Line(1);                       /* select line */
	if (length > lcd_MAX_LCD_LINE_CHARS) // Mas de una linea
	{	// Hacemos la primera linea y si hay un espacio la acabamos
		for(i = 0; i < lcd_MAX_LCD_LINE_CHARS; i++, str++)
		{
			lcd_Write(*str);
			if (*str == ' ')
			{
				/* Clear the rest of the line */
				for (; i < lcd_MAX_LCD_LINE_CHARS; i++) {
					lcd_Write(' ');
				}
			}
		}
		// Buscamos el siguiente caracter no blanco del mensaje
		while (*str == ' '  &&  i < length)
		{
			str++;
			i++;
		}
		// Hacemos la segunda linea y rellenamos de blancos
		lcd_Line(2);                 /* select line */
		for(i = 0; i < lcd_MAX_LCD_LINE_CHARS; i++, str++)
		{
			if (*str != ' ' && *str != '\0')
			{
				lcd_Write(*str);
			}
			else
			{
				/* Clear the rest of the line */
				for (; i < lcd_MAX_LCD_LINE_CHARS; i++) {
					lcd_Write(' ');
				}
			}
		}
	}
	else  // Una sola linea
	{
		for(i = 0; i < lcd_MAX_LCD_LINE_CHARS && *str!='\0'; i++, str++) {
			lcd_Write(*str);
		}
		/* Clear the rest of the line */
		for (; i <= lcd_MAX_LCD_LINE_CHARS; i++) {
			lcd_Write(' ');
		}
		lcd_Line(2);                 /* select line */
		/* Clear the rest of the line */
		for (i = 0; i <= lcd_MAX_LCD_LINE_CHARS; i++) {
			lcd_Write(' ');
		}
	}
}

/*
 ** ===================================================================
 **     Method      :  lcd_Line (component LCDHTA)
 **     Description :
 **         Sets the current line.
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         line            - Line number, starting with 1
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_Line(uint8_t line)
{
	lcd_WriteLCDCommand((uint8_t)(line==1?FirstLineCmd:SecondLineCmd));
}

/*
 ** ===================================================================
 **     Method      :  lcd_Init (component LCDHTA)
 **
 **     Description :
 **         Display driver initialization routine.
 **         This method is internal. It is used by Processor Expert only.
 ** ===================================================================
 */
void lcd_Init(void)
{
	/* This function initializes the driver.
     The low level init already shall have set our data port to input/output, currently set to output,
     plus all control pins are set as outputs with low values. To be sure, we do it here again. */
	ClrEN();                              /* EN Pin low */
	ClrRW();                              /* RW Pin low */
	ClrRS();                              /* RS Pin low: command mode */
	DataPut(0);

	/* make pins output */
	DataAsOutput();
	ENAsOutput();
	RWAsOutput();
	RSAsOutput();

	Waitms(50);

	lcd_WriteLCDCommand(FunctionSetCmd|FunctionSet_Font5x8
			|FunctionSet_8bit      /* we are using 8bit data bus */ \
			|FunctionSet_2Lines    /* we are using two or more lines */
	);

	DisplayOnOffControlStatus = DisplayOnOffControlCmd|DisplayOnOffControl_DisplayOn; /* Display on, cursor on, do not blink */
	lcd_WriteLCDCommand(DisplayOnOffControlStatus);
	lcd_WriteLCDCommand(ClearDisplayCmd); /* Clear display */
	lcd_WriteLCDCommand(ReturnHomeCmd);   /* Return home */
	lcd_WriteLCDCommand(EntryModeSetCmd|EntryModeSet_IncrementOn); /* Entry mode set: Increment mode, display shift off */

	lcd_LoadSoftChar(lcd_SOFTCHAR_MAG_ARROW, (uint8_t*) lcd_SoftCharMAG);
	lcd_LoadSoftChar(lcd_SOFTCHAR_LEFT_UP_BOX, (uint8_t*) lcd_SoftCharLEFTBOXUP);
	lcd_LoadSoftChar(lcd_SOFTCHAR_CENTER_UP_BOX, (uint8_t*) lcd_SoftCharCENTERBOXUP);
	lcd_LoadSoftChar(lcd_SOFTCHAR_RIGHT_UP_BOX, (uint8_t*) lcd_SoftCharRIGHTBOXUP);
	lcd_LoadSoftChar(lcd_SOFTCHAR_LEFT_DOWN_BOX, (uint8_t*) lcd_SoftCharLEFTBOXDOWN);
	lcd_LoadSoftChar(lcd_SOFTCHAR_CENTER_DOWN_BOX, (uint8_t*) lcd_SoftCharCENTERBOXDOWN);
	lcd_LoadSoftChar(lcd_SOFTCHAR_RIGHT_DOWN_BOX, (uint8_t*) lcd_SoftCharRIGHTBOXDOWN);
}

/*
 ** ===================================================================
 **     Method      :  lcd_LoadSoftChar (component LCDHTA)
 **     Description :
 **         Loads a user defined (softchar) into the display CGRAM.
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         charCode        - The character code to be defined
 **                           (0..7)
 **       * softChar        - Pointer to an array of 8 bytes
 **                           defining the soft character
 **                           Example of the soft character 'ü':
 **                           const uint8_t SoftCharUE[8] = { // ü
 **                           0x11, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0d, 0
 **                           //  X...X
 **                           //  .....
 **                           //  X...X
 **                           //  X...X
 **                           //  X...X
 **                           //  X..XX
 **                           //  .XX.X
 **                           };
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_LoadSoftChar(uint8_t charCode, uint8_t *softChar)
{
	/* Loads a user defined character (soft character, 5x8 dots) into the CG-RAM
     in the display. The character can be used afterwards like a normal character code */
#define CGAddress 0x40                /* Base address for softchars */
#define DDAddress 0x80                /* To finish the download mode */
	uint8_t i;

	lcd_WriteLCDCommand((uint8_t)(CGAddress + (charCode * 0x08))); /* Set CG Ram: Character code * 0x08 [size] */
	for (i=0; i<=7; i++){
		lcd_Write(softChar[i]);
	}
	lcd_WriteLCDCommand(DDAddress);       /* finish the download */
}

/*
 ** ===================================================================
 **     Method      :  lcd_ShiftRight (component LCDHTA)
 **     Description :
 **         Shifts all characters to the right.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_ShiftRight(void)
{
	lcd_WriteLCDCommand(RightShiftCmd);
}

/*
 ** ===================================================================
 **     Method      :  lcd_CursorOn (component LCDHTA)
 **     Description :
 **         Enables the cursor.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_CursorOn(void)
{
	DisplayOnOffControlStatus |= DisplayOnOffControl_CursorOn;
	lcd_WriteLCDCommand(DisplayOnOffControlStatus);
}

/*
 ** ===================================================================
 **     Method      :  lcd_CursorOff (component LCDHTA)
 **     Description :
 **         Disables the cursor.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_CursorOff(void)
{
	DisplayOnOffControlStatus &= ~DisplayOnOffControl_CursorOn;
	lcd_WriteLCDCommand(DisplayOnOffControlStatus);
}

/*
 ** ===================================================================
 **     Method      :  lcd_BlinkingOn (component LCDHTA)
 **     Description :
 **         Sends the display off command to the display.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_BlinkingOn(void)
{
	DisplayOnOffControlStatus |= DisplayOnOffControl_BlinkOn;
	lcd_WriteLCDCommand(DisplayOnOffControlStatus);
}

/*
 ** ===================================================================
 **     Method      :  lcd_BlinkingOff (component LCDHTA)
 **     Description :
 **         Puts the display in blinking off mode.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_BlinkingOff(void)
{
	DisplayOnOffControlStatus &= ~DisplayOnOffControl_BlinkOn;
	lcd_WriteLCDCommand(DisplayOnOffControlStatus);
}

/*
 ** ===================================================================
 **     Method      :  lcd_SetEntryMode (component LCDHTA)
 **     Description :
 **         Configures the display entry mode, if the cursor has to
 **         shift and/or if the display shall shift content while
 **         displaying text.
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         increment       - Increments (TRUE) or
 **                           decrements (FALSE) the display address by 1
 **                           when a character code is written into or
 **                           read from DDRAM. The cursor or blinking
 **                           moves to the right when incremented by 1
 **                           and to the left when decremented by 1.
 **         shiftLeft       - The display does not shift if
 **                           the 'shift' is FALSE. If 'shift' is TRUE,
 **                           it will seem as if the cursor does not move
 **                           but the display does.
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_SetEntryMode(bool increment, bool shiftLeft)
{
	uint8_t flags = 0;

	if (increment) {
		flags |= EntryModeSet_IncrementOn;
	}
	if (shiftLeft) {
		flags |= EntryModeSet_ShiftOn;
	}
	lcd_WriteLCDCommand((uint8_t)(EntryModeSetCmd|flags)); /* Entry mode set: Increment mode, display shift mode */
}

/*
 ** ===================================================================
 **     Method      :  lcd_UseDisplay (component LCDHTA)
 **     Description :
 **
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         display         - Has to be either 1 (top display,
 **                           using E1) or 2 (bottom display, using E2)
 **     Returns     :
 **         ---             - Error code
 ** ===================================================================
 */
uint8_t lcd_UseDisplay(uint8_t display)
{
	(void)display; /* not used, as not using E2 (additional enable) signal */
	return ERR_OK;
}

/*
 ** ===================================================================
 **     Method      :  lcd_CursorShiftRight (component LCDHTA)
 **     Description :
 **         Shift the cursor to the right.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_CursorShiftRight(void)
{
	lcd_WriteLCDCommand(RightShiftCursor);
}

/*
 ** ===================================================================
 **     Method      :  lcd_CursorShiftLeft (component LCDHTA)
 **     Description :
 **         Shift the cursor to the left.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void lcd_CursorShiftLeft(void)
{
	lcd_WriteLCDCommand(LeftShiftCursor);
}

/* END lcd. */
